
Question: 1
Project Submission Task
As per the problem statement mentioned below, please develop and submit your project before the deadline.
c
Question 1: Upload your project to a GitHub repository and ensure that it is set to public visibility. Copy the repository link, paste it into a document, and
upload the document in the submission section.
Question 2: Upload your deployed project link. Copy the deployed project link (from any deployment platform), paste it into a document, and upload the
document in the submission section.
Question 3: Upload the project documentation in PDF format.
Question 4: Upload a demo video of your project (maximum duration: 3 minutes) in MP4 format.
Please ensure that all submitted documents, files, and links are accessible for evaluation.

Problem Statement: Digital Fraud Awareness and Detection Platform
Problem Description-
Digital payment adoption and mobile connectivity in India have grown rapidly, but this growth has also led to a significant increase in digital fraud incidents.
Citizens regularly receive fraudulent SMS messages, WhatsApp texts, and phone calls that impersonate banks, courier services, government agencies, or
popular platforms. These messages often use fear, urgency, or rewards to manipulate users into sharing sensitive information such as OTPs, bank details,
or personal identifiers. A major challenge is that most users are unable to differentiate between genuine and fraudulent communications in real time.
Existing awareness campaigns are mostly static, reactive, or text-heavy, and they do not provide contextual, message-specific guidance. As a result, many
users fall victim to scams even when basic warning signs are present. There is a clear need for a simple, accessible system that can analyze digital
messages, flag potential fraud, explain risks in understandable language, and educate users on safe digital behavior.



Proposed Workflow-
The workflow begins when a user pastes an SMS message, WhatsApp text, or call transcript into the system. Once submitted, the message is first
processed by a rule-based analysis engine that checks for predefined fraud indicators such as urgent language, OTP requests, suspicious links,
impersonation keywords, and personal data requests. Based on these checks, the system assigns an initial risk level and generates a basic explanation. In
parallel, the same message is processed by an Al-based NLP model trained to detect scam-like language patterns. The Al model produces a probability
score indicating how likely the message is to be fraudulent and identifies key phrases that contribute to this risk. The system then combines the rule-
based score and the Al-generated score using a weighted logic to determine a final risk classification. The final output is presented to the user in a clear
dashboard showing the risk level, scam probability, highlighted suspicious phrases, and simple safety guidance. Optionally, the system logs analyzed
messages to allow users to review past checks and observe common scam trends.

What the System Solves-
This system addresses the problem of real-time fraud awareness rather than post-incident reporting. It helps users make informed decisions before
they respond to suspicious messages. By providing both detection and explanation, the platform reduces dependence on technical knowledge and
empowers users to recognize scams independently over time. The solution also bridges the gap between static fraud education and real-world usage by
contextualizing warnings around the exact message received. This improves user trust, understanding, and retention of safe digital practices.
System Requirements and Components-
To build this system, the following components are required:
â€¢ A user interface for message input and result display.
â€¢ A rule-based fraud detection engine using predefined keywords and patterns
â€¢ A workflow manager to combine rule-based and Al-based outputs
â€¢ An NLP-based Al model for scam probability prediction
â€¢ A phrase-highlighting mechanism for explain ability
â€¢ A data storage mechanism for logging analyzed messages (optional but recommended)
â€¢ Educational content covering common scam types and safety guidelines
The system can be implemented using a lightweight backend with Python, a simple web-based frontend, and an open-source NLP library. No external
real-time APIs are required, making the solution suitable for low-resource environments and offline-first extensions.

---

Now I will structure this correctly.

We will create:

> **A high-quality MVP that looks production-grade**

Because youâ€™re solo, we must balance:

* Technical depth
* Realistic timeline
* Clean architecture
* Judgesâ€™ expectations

---

# ðŸ“˜ MASTER DOCUMENT STRUCTURE

(We Start Now â€“ Version 1.0 Draft)

---

# SECTION 1: PRODUCT DEFINITION & SCOPE

I will write this like a professional technical document.

---

## 1.1 Product Overview

The Digital Fraud Awareness and Detection Platform is a web-based system designed to analyze user-submitted digital messages (SMS, WhatsApp text, or call transcripts) and determine the likelihood of fraud using a hybrid detection approach combining rule-based heuristics and machine learning classification.

The system provides:

* Real-time fraud risk classification
* Contextual explanation of risk factors
* Highlighted suspicious phrases
* Educational guidance for safe action
* Optional logging for user review

The primary goal is to empower users to make informed decisions before interacting with potentially fraudulent communications.

---

## 1.2 Objectives

### Primary Objectives

1. Provide real-time fraud risk assessment.
2. Combine rule-based detection and ML-based probability scoring.
3. Deliver explainable results in simple language.
4. Maintain high usability and clarity.

### Secondary Objectives

1. Enable public deployment.
2. Support offline extensibility.
3. Maintain modular architecture for future scalability.

---

## 1.3 Target Users

* General digital payment users
* Individuals unfamiliar with scam patterns
* Students
* Working professionals
* Senior citizens (secondary focus)

---

## 1.4 Core Functional Requirements

### FR-1: Message Input

The system shall allow users to paste a digital message into a text field.

### FR-2: Rule-Based Analysis

The system shall evaluate the message against predefined fraud indicators.

### FR-3: ML-Based Classification

The system shall compute scam probability using a trained classifier.

### FR-4: Hybrid Risk Computation

The system shall combine rule score and ML probability into a final risk score.

### FR-5: Risk Classification

The system shall categorize output as:

* Low Risk
* Medium Risk
* High Risk

### FR-6: Phrase Highlighting

The system shall highlight suspicious terms detected in the message.

### FR-7: Explanation Generation

The system shall provide human-readable reasoning for classification.

### FR-8: Educational Guidance

The system shall provide recommended actions based on risk level.

### FR-9: Logging (Optional but Recommended)

The system shall store analyzed messages with metadata.

---

## 1.5 Non-Functional Requirements

### NFR-1 Performance

* Response time < 2 seconds per request.

### NFR-2 Reliability

* System should not crash on malformed input.

### NFR-3 Security

* Sanitize input.
* Prevent injection attacks.
* Secure API endpoints.

### NFR-4 Usability

* Risk level visible within 3 seconds.
* Mobile responsive design.

### NFR-5 Scalability (Future Ready)

* Modular architecture.
* Separate ML inference module.

---

# SECTION 2: SYSTEM ARCHITECTURE OVERVIEW

Because you're using FastAPI + React, this is good architecture.

---

## 2.1 High-Level Architecture

Frontend (React)
â¬‡
FastAPI Backend
â¬‡
Fraud Engine Module
â”œâ”€â”€ Rule Engine
â”œâ”€â”€ ML Model
â””â”€â”€ Hybrid Scoring
â¬‡
Database (SQLite initially)

---

## 2.2 Component Breakdown

### 1ï¸âƒ£ Frontend Layer

* Input form
* Risk display dashboard
* Highlight rendering
* Educational panel
* History panel

### 2ï¸âƒ£ Backend API Layer

* POST /analyze
* GET /history
* GET /education

### 3ï¸âƒ£ Detection Engine

* Rule Engine Module
* ML Inference Module
* Hybrid Score Calculator

### 4ï¸âƒ£ Data Storage

* SQLite DB
* Message logs table

---

# ðŸ”¥ Now We Address Your Biggest Risk

You do not have dataset.

This is critical.

Without dataset:

* ML model will be weak
* Judges may question credibility

---

# ðŸ“Š Dataset Strategy (High Quality Without Compromise)

Since you're solo, here's smart approach:

### Step 1: Public Datasets

Use:

* SMS Spam Collection Dataset (UCI)
* Kaggle SMS Spam datasets
* Phishing message datasets

### Step 2: Curate Scam-Specific Messages

Manually add:

* Bank impersonation
* KYC scams
* OTP scams
* Courier scams
* Job scams
* Reward scams

Target:

* 2,000â€“5,000 messages minimum

Perfect.
1 day. Solo. FastAPI + React. No auth. Admin rule panel required.
And no compromise on quality.

Good. Now we design this intelligently.

Because with 1 day, the goal is:

> ðŸš€ Build a technically clean, architecturally correct, judge-impressive MVP
> that LOOKS production-grade even if internally simplified.

We will now formally draft:

# ðŸ“˜ SECTION 3 â€“ FRAUD DETECTION ENGINE DESIGN

(Production-style documentation, MVP-realistic implementation)

---

# 3. Fraud Detection Engine

## 3.1 Overview

The Fraud Detection Engine is the core analytical component of the system.
It operates using a **hybrid detection mechanism**:

1. Rule-Based Heuristic Analysis
2. Machine Learning Classification (TF-IDF + Logistic Regression)
3. Weighted Hybrid Risk Aggregation

The final output is a normalized risk score between 0 and 1 and a categorical risk level.

---

# 3.2 Rule-Based Detection Engine

## 3.2.1 Purpose

The rule engine detects explicit fraud indicators using deterministic logic.
It improves interpretability and handles clear scam signals.

---

## 3.2.2 Fraud Indicator Categories

Each category has weight assigned.

### A. Urgency Indicators (Weight: 0.15)

Examples:

* urgent
* immediately
* within 2 hours
* last chance
* act now
* final warning

Detection Method:

* Keyword matching
* Regex for time-bound phrases

---

### B. OTP / Credential Request (Weight: 0.25)

Examples:

* share otp
* provide otp
* send verification code
* confirm pin
* update password

This category gets highest weight.

---

### C. Suspicious Links (Weight: 0.20)

Detection:

* Presence of http/https
* Shortened URLs (bit.ly, tinyurl, cutt.ly)
* Mismatch between brand name and domain

---

### D. Impersonation Keywords (Weight: 0.20)

Examples:

* bank
* rbi
* sbi
* hdfc
* courier
* income tax department
* government

Triggered only if paired with action verbs.

---

### E. Reward / Fear Language (Weight: 0.10)

Examples:

* you won
* prize
* lottery
* account blocked
* legal action
* suspend

---

### F. Personal Information Request (Weight: 0.10)

Examples:

* aadhaar
* pan number
* account number
* cvv

---

## 3.2.3 Rule Score Calculation

Each category contributes weight if triggered.

Formula:

Rule Score =
(sum of triggered category weights)

Max possible = 1.0

Normalize to range [0, 1]

---

## 3.2.4 Rule Output

Return structure:

{
"rule_score": 0.65,
"triggered_rules": [
"Urgency",
"OTP Request",
"Suspicious Link"
],
"matched_phrases": [
"urgent",
"share otp",
"bit.ly"
]
}

---

# 3.3 Machine Learning Module

## 3.3.1 Model Type

* TF-IDF Vectorizer
* Logistic Regression classifier
* Binary output: Scam (1) / Legitimate (0)

---

## 3.3.2 Dataset Strategy (1-Day Realistic Plan)

Since no dataset:

### Step 1:

Download:

* SMS Spam Collection Dataset
* Kaggle phishing datasets

### Step 2:

Manually add 50â€“100 India-specific scam examples.

### Step 3:

Balance classes.

Target minimum:
1,000â€“2,000 messages

---

## 3.3.3 Preprocessing

* Lowercasing
* Remove punctuation
* Remove extra spaces
* Keep stopwords (important for context)
* No stemming (to save time)

---

## 3.3.4 Training Configuration

TF-IDF:

* max_features = 5000
* ngram_range = (1,2)

Logistic Regression:

* solver = 'liblinear'
* class_weight = 'balanced'

---

## 3.3.5 Output

Model returns:

{
"ml_probability": 0.72
}

---

# 3.4 Hybrid Scoring Logic

## 3.4.1 Weighted Fusion

Since rule engine improves explainability, we balance:

Final Risk Score =
(0.4 Ã— Rule Score) + (0.6 Ã— ML Probability)

Reason:
ML handles patterns better.
Rules handle explicit fraud signals.

---

## 3.4.2 Risk Thresholds

0.0 â€“ 0.30 â†’ Low Risk
0.31 â€“ 0.60 â†’ Medium Risk
0.61 â€“ 1.00 â†’ High Risk

---

## 3.4.3 Edge Case Handling

Case 1:
High rule score but low ML score
â†’ Still classify as Medium (minimum)

Case 2:
No rules triggered but ML high
â†’ Medium or High based on probability

Case 3:
Short message (< 5 words)
â†’ Flag as "Insufficient Context"

---

# 3.5 Explainability Layer

For each triggered rule:

Map to explanation template:

Example:

If OTP rule triggered:
"This message asks for OTP. Legitimate institutions do not request OTP via SMS."

If urgency triggered:
"This message creates urgency to pressure quick action."

If suspicious link:
"The message contains a shortened or external link, commonly used in phishing."

---

# 3.6 Performance Expectations

* Inference time: < 500ms
* Combined response: < 2 seconds
* Memory usage: < 200MB

---

# ðŸ§  ADMIN PANEL (Since You Said YES)

Minimal Admin Features:

* Add new keyword
* Edit rule weight
* Enable/Disable rule
* View rule list

No auth required (hackathon scope).

Admin endpoints:

POST /admin/add-rule
PUT /admin/update-rule
GET /admin/rules

Rules stored in JSON file or DB table.

---

# ðŸš¨ CRITICAL 1-DAY STRATEGY

Here is the execution order:

1. Train model first
2. Build rule engine
3. Build hybrid scoring
4. Build FastAPI endpoint
5. Connect React
6. Add admin panel
7. Deploy

Do NOT build UI first.


Excellent choice âœ…
JSON gives you:

* Clean separation of logic
* Easy admin updates
* Dynamic rule loading
* Production-like structure
* No DB overhead for rules

Now we move forward formally.

---

# ðŸ“˜ SECTION 4 â€“ API DESIGN SPECIFICATION

This section defines all backend endpoints, schemas, and interaction contracts.

Your backend will be:

> FastAPI-based REST API
> Modular
> Stateless
> Publicly deployable

---

# 4.1 API Architecture Overview

Frontend (React)
â¬‡
POST /analyze
â¬‡
Fraud Engine
â¬‡
Return JSON Response
â¬‡
Render Risk Dashboard

Admin Flow:

Frontend Admin Panel
â¬‡
GET /admin/rules
POST /admin/rules
PUT /admin/rules/{id}

---

# 4.2 Core Endpoint â€“ Message Analysis

## Endpoint

POST /analyze

---

## Request Body

```json
{
  "message": "Your SBI account will be blocked in 2 hours. Click here: bit.ly/xyz"
}
```

Validation Rules:

* Must not be empty
* Max length: 2000 characters
* Strip leading/trailing whitespace

---

## Response Structure

```json
{
  "risk_level": "High",
  "final_score": 0.74,
  "rule_score": 0.65,
  "ml_probability": 0.81,
  "triggered_rules": [
    "Urgency",
    "OTP Request",
    "Suspicious Link"
  ],
  "matched_phrases": [
    "blocked in 2 hours",
    "bit.ly"
  ],
  "explanations": [
    "This message creates urgency to pressure quick action.",
    "The message contains a shortened link commonly used in phishing."
  ],
  "recommendation": "Do NOT click the link. Contact your bank directly using official channels."
}
```

---

# 4.3 Risk Recommendation Mapping

Based on final_score:

Low:
"Message appears safe, but always verify unknown links."

Medium:
"Exercise caution. Do not share sensitive information."

High:
"This message is likely fraudulent. Do not interact with it."

---

# 4.4 Admin Rule Management Endpoints

Rules stored in:

rules.json

---

## JSON Structure Design

```json
[
  {
    "id": 1,
    "category": "Urgency",
    "weight": 0.15,
    "keywords": [
      "urgent",
      "immediately",
      "act now",
      "within 2 hours"
    ],
    "enabled": true
  },
  {
    "id": 2,
    "category": "OTP Request",
    "weight": 0.25,
    "keywords": [
      "share otp",
      "verification code",
      "confirm pin"
    ],
    "enabled": true
  }
]
```

---

## GET /admin/rules

Returns full rules JSON.

---

## POST /admin/rules

Adds new rule.

Request:

```json
{
  "category": "Lottery Scam",
  "weight": 0.10,
  "keywords": ["you won", "lottery", "claim prize"]
}
```

---

## PUT /admin/rules/{id}

Update weight, keywords, or enable/disable.

---

# 4.5 Optional Logging Endpoint

If implementing logging:

POST /log
GET /history

Log schema:

```json
{
  "message": "...",
  "final_score": 0.74,
  "risk_level": "High",
  "timestamp": "2026-02-21T10:22:11"
}
```

SQLite table:

messages

* id
* message
* rule_score
* ml_probability
* final_score
* risk_level
* timestamp

---

# ðŸ“˜ SECTION 5 â€“ PROJECT FOLDER STRUCTURE

Very important for quality.

```
fraud-detection-platform/

backend/
â”‚
â”œâ”€â”€ main.py
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ vectorizer.pkl
â”‚   â”œâ”€â”€ classifier.pkl
â”‚
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ rule_engine.py
â”‚   â”œâ”€â”€ ml_engine.py
â”‚   â”œâ”€â”€ hybrid.py
â”‚
â”œâ”€â”€ admin/
â”‚   â”œâ”€â”€ rules.json
â”‚
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ models.py
â”‚   â”œâ”€â”€ db.py
â”‚
â””â”€â”€ requirements.txt

frontend/
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ InputBox.jsx
â”‚   â”‚   â”œâ”€â”€ RiskDisplay.jsx
â”‚   â”‚   â”œâ”€â”€ HighlightedText.jsx
â”‚   â”‚   â”œâ”€â”€ AdminPanel.jsx
â”‚   â”‚
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Home.jsx
â”‚   â”‚   â”œâ”€â”€ Admin.jsx
â”‚   â”‚
â”‚   â”œâ”€â”€ api.js
â”‚
â””â”€â”€ package.json
```

This structure screams professionalism.

---

# ðŸ“˜ SECTION 6 â€“ ERROR HANDLING STRATEGY

Case: Empty input
Return 400

Case: Model not loaded
Return 500

Case: Rule JSON corrupted
Fallback to safe default rules

Case: Message too short
Return:
"Insufficient context for reliable analysis."

---

# ðŸ“˜ SECTION 7 â€“ SECURITY CONSIDERATIONS

Even without auth:

* Escape HTML before rendering
* Sanitize inputs
* Limit request body size
* Disable CORS wide open in production
* Use HTTPS deployment

---

# ðŸš¨ CRITICAL: 1-DAY BUILD STRATEGY

Your realistic timeline:

Hours 1â€“3:

* Dataset collection + training

Hours 3â€“5:

* Rule engine

Hours 5â€“7:

* FastAPI integration

Hours 7â€“10:

* React UI

Hours 10â€“12:

* Admin panel

Hours 12â€“14:

* Deployment + testing

